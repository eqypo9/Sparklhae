[
  {
    "id": "hellofit",
    "name": "HELLOFIT",
    "description": "지도 기반 주변 인기 스포츠 시설을 간편하게 탐색하는 웹 서비스",
    "image": "/images/projects/hellofit.png",
    "techStack": [
      "React",
      "Next.js",
      "TypeScript",
      "Recoil",
      "React Query",
      "Axios",
      "SCSS",
      "ESlint",
      "Prettier"
    ],
    "deployLink": "https://www.hellofit.site/",
    "githubLink": "https://github.com/eqypo9/HelloFit_Front",
    "team": true,
    "teamSize": 4,
    "teamMembers": {
      "Frontend": 2,
      "Backend": 1,
      "Designer": 1
    },
    "overview": {
      "title": "HELLOFIT 프로젝트 개요",
      "content": [
        "HELLOFIT은 공공데이터를 활용하여 스포츠 이용권이 적용되는 시설을 쉽게 탐색할 수 있는 서비스입니다.",
        "기존 스포츠 강좌 예약 시스템에서는 시설의 위치, 이용권 적용 여부, 강좌 정보를 개별적으로 확인해야 하는 번거로움이 있었습니다.",
        "HELLOFIT은 지도 기반 탐색, 인기 시설 추천, 후기 시스템을 통해 사용자가 보다 직관적으로 원하는 정보를 찾을 수 있도록 UX를 개선하는 것을 목표로 합니다.",
        "또한, 필터링과 맞춤형 추천 기능을 강화하여 사용자들이 자신에게 최적화된 스포츠 시설을 쉽게 찾을 수 있도록 설계되었습니다."
      ]
    },
    "featuresDetail": [
      {
        "title": "지도 기반 스포츠 시설 탐색",
        "description": "사용자의 현재 위치를 기반으로 가까운 스포츠 시설을 한눈에 확인할 수 있습니다. 필터를 활용하여 원하는 시설을 더욱 빠르게 찾을 수 있습니다.",
        "image": "/images/projects/hellofit/overview_1.png"
      },
      {
        "title": "이용권 유형별 맞춤 정보 제공",
        "description": "일반 이용권과 장애인 이용권을 구분하여 맞춤형 정보를 제공합니다. 사용자는 자신의 이용권에 해당하는 강좌만 확인할 수 있어 검색 효율이 높아집니다.",
        "image": "/images/projects/hellofit/overview_2.png"
      },
      {
        "title": "누적 수강생 수 기반 인기 스포츠 종목 추천",
        "description": "이용자 데이터를 분석하여 가장 인기 있는 스포츠 종목을 추천합니다. 이를 통해 사용자들은 인기 있는 강좌를 쉽게 찾을 수 있습니다.",
        "image": "/images/projects/hellofit/overview_4.png"
      },
      {
        "title": "지역별 인기 시설 추천",
        "description": "누적 수강생 수 데이터를 기반으로 지역별 인기 시설을 추천하여 맞춤형 탐색 기능을 제공합니다.",
        "image": "/images/projects/hellofit/overview_5.png"
      },
      {
        "title": "시설 후기 및 별점 시스템",
        "description": "사용자들이 직접 남긴 후기를 확인하고 별점 평가를 참고하여 최적의 시설을 선택할 수 있습니다.",
        "image": "/images/projects/hellofit/overview_6.png"
      },
      {
        "title": "관심 시설 저장 및 알림 기능",
        "description": "자주 이용하는 시설을 저장하고, 신규 강좌가 개설될 경우 알림을 받을 수 있는 기능을 제공합니다.",
        "image": "/images/projects/hellofit/overview_7.png"
      }
    ],
    "development": {
      "title": "개발 과정",
      "sections": [
        {
          "title": "핵심 기여",
          "content": [
            "공공데이터 API를 활용하여 스포츠 시설 데이터를 동적으로 로드하는 기능 구현",
            "NextAuth를 활용한 소셜 로그인 (Google, Kakao) 도입",
            "사용자 경험을 고려한 UI/UX 개선: 지도 기반 탐색 최적화 및 필터링 기능 강화",
            "카카오 지도 API와 Recoil을 결합하여 상태 관리를 최적화하여 성능 개선"
          ]
        },
        {
          "title": "카카오 지도 API 성능 최적화",
          "content": [
            "카카오 지도 API의 불필요한 중복 실행을 방지하기 위해 useKakaoMapLoader 훅을 도입.",
            "지도 초기화 과정에서 useEffect를 활용하여 API 스크립트 로드와 상태 관리를 최적화.",
            "역지오코딩을 적용하여 사용자의 현재 위치를 기반으로 자동으로 지역명을 설정."
          ],
          "code": {
            "description": "카카오 지도 API 스크립트 로드 및 사용자의 현재 위치 적용",
            "snippet": "import { useEffect, useState } from 'react';\n\nconst useKakaoMapLoader = (mapContainerId) => {\n  const [map, setMap] = useState(null);\n  \n  useEffect(() => {\n    const loadScript = () => {\n      if (window.kakao && window.kakao.maps) {\n        initMap();\n        return;\n      }\n      \n      const script = document.createElement('script');\n      script.src = 'https://dapi.kakao.com/v2/maps/sdk.js?appkey=YOUR_APP_KEY&libraries=services&autoload=false';\n      script.async = true;\n      script.onload = () => {\n        window.kakao.maps.load(() => initMap());\n      };\n      document.head.appendChild(script);\n    };\n\n    const initMap = () => {\n      const container = document.getElementById(mapContainerId);\n      const options = { center: new window.kakao.maps.LatLng(37.5665, 126.978), level: 5 };\n      const kakaoMap = new window.kakao.maps.Map(container, options);\n      setMap(kakaoMap);\n      getUserLocation(kakaoMap);\n    };\n\n    const getUserLocation = (mapInstance) => {\n      if (navigator.geolocation) {\n        navigator.geolocation.getCurrentPosition((position) => {\n          const userLatLng = new window.kakao.maps.LatLng(position.coords.latitude, position.coords.longitude);\n          mapInstance.setCenter(userLatLng);\n          reverseGeocode(userLatLng);\n        });\n      }\n    };\n\n    const reverseGeocode = (latLng) => {\n      const geocoder = new window.kakao.maps.services.Geocoder();\n      geocoder.coord2RegionCode(latLng.getLng(), latLng.getLat(), (result, status) => {\n        if (status === window.kakao.maps.services.Status.OK) {\n          console.log('현재 위치:', result[0].address_name);\n        }\n      });\n    };\n\n    loadScript();\n  }, [mapContainerId]);\n};"
          }
        },
        {
          "title": "마커 렌더링 최적화",
          "content": [
            "기존 방식에서는 시설 목록이 변경될 때마다 모든 마커를 삭제하고 다시 생성하여 성능 저하 발생",
            "useFacilityMarkers 훅을 활용하여 기존 마커를 유지하면서 필요한 경우만 업데이트",
            "좌표 변환을 병렬 처리하여 로딩 속도를 개선하고, UI 깜빡임 문제를 해결"
          ],
          "code": {
            "description": "좌표 변환을 병렬 처리하여 마커 렌더링 속도를 개선하는 코드",
            "snippet": "const coordinates = await Promise.all(facilities.map(facility => fetchCoordinates(facility)));"
          }
        },
        {
          "title": "Recoil을 활용한 지도 필터 상태 관리",
          "content": [
            "Recoil을 활용하여 사용자가 선택한 스포츠 종목 필터를 상태로 관리.",
            "필터 상태가 변경될 때마다 마커가 갱신되도록 구현."
          ],
          "code": {
            "description": "Recoil을 활용한 지도 필터 상태 코드",
            "snippet": "import { atom, selector } from 'recoil';\n\nexport const selectedSportState = atom({\n  key: 'selectedSport',\n  default: '전체',\n});\n\nexport const filteredFacilitiesState = selector({\n  key: 'filteredFacilities',\n  get: ({ get }) => {\n    const selectedSport = get(selectedSportState);\n    return facilities.filter(facility => facility.sport === selectedSport);\n  }\n});"
          }
        },
        {
          "title": "검색 및 API 호출 최적화",
          "content": [
            "AbortController를 활용하여 검색 중 새로운 요청이 들어오면 기존 요청을 취소하여 불필요한 API 호출 방지",
            "useMemo와 debounce를 적용하여 연속적인 검색에도 성능 저하가 발생하지 않도록 개선",
            "검색 결과가 없을 경우 사용자에게 명확한 피드백을 제공하여 UX 개선"
          ],
          "code": {
            "description": "AbortController를 활용하여 불필요한 API 요청을 방지하는 코드",
            "snippet": "if (abortControllerRef.current) { abortControllerRef.current.abort(); }"
          }
        },
        {
          "title": "UI/UX 개선",
          "content": [
            "이용권 유형별 필터 제공 (일반/장애인)으로 사용자 맞춤 탐색 기능 강화",
            "반응형 디자인을 적용하여 모바일 환경에서도 원활한 탐색 가능",
            "UX 테스트를 통해 검색 및 필터링 로직을 개선하여 사용자의 피드백을 반영"
          ],
          "code": {
            "description": "이용권 유형별 필터 기능을 구현한 코드",
            "snippet": "const filteredFacilities = facilities.filter(facility => facility.type === selectedType);"
          }
        }
      ]
    },
    "troubleshooting": {
      "title": "트러블슈팅",
      "issues": [
        {
          "title": "마커 플리커 현상 & 과도한 API 호출 문제",
          "problem": "시설 목록이 변경될 때마다 기존 마커를 삭제하고 새로 생성하여 UI가 깜빡이며, 과도한 API 요청이 발생하여 성능이 저하됨.",
          "solution": [
            "useFacilityMarkers 훅을 도입하여 기존 마커를 유지하며 필요한 경우만 업데이트.",
            "AbortController를 활용하여 불필요한 API 요청을 방지.",
            "좌표 변환(fetchCoordinates)을 병렬 처리하여 렌더링 속도 개선."
          ],
          "lesson": "API 호출을 최적화하는 것이 성능 개선에 중요한 영향을 미친다는 점을 실감했습니다. 특히, 불필요한 리렌더링을 줄이는 것이 사용자 경험(UX)에 미치는 영향을 직접 확인할 수 있었습니다.",
          "code": {
            "description": "좌표 변환을 병렬 처리하여 렌더링 속도를 개선",
            "snippet": "const coordinates = await Promise.all(facilities.map(facility => fetchCoordinates(facility)));"
          }
        },
        {
          "title": "현재 위치 탐색 시 불필요한 API 호출 문제",
          "problem": "사용자가 현재 위치 버튼을 여러 번 클릭하면 같은 API 요청이 반복 호출되면서 성능이 저하됨.",
          "solution": [
            "usePositionButton 훅을 활용하여 사용자의 위치를 캐싱하고, 한 번 가져온 위치를 재사용하도록 개선.",
            "위치 허용 여부를 확인하여 허용하지 않을 경우 기본 위치를 설정."
          ],
          "lesson": "사용자의 행동 패턴을 고려하여 API 요청을 최적화하는 것이 중요하다는 점을 배웠습니다. 불필요한 중복 요청을 줄이는 방식(캐싱, 상태 관리 등)을 적용하면 성능과 UX를 동시에 개선할 수 있음을 경험했습니다.",
          "code": {
            "description": "사용자의 위치를 캐싱하여 불필요한 호출 방지",
            "snippet": "const [cachedLocation, setCachedLocation] = useState(null);\nconst moveToUserLocation = () => {\n  if (cachedLocation) { map.setCenter(cachedLocation); return; }\n  navigator.geolocation.getCurrentPosition(position => {\n    const userLatLng = new kakao.maps.LatLng(position.coords.latitude, position.coords.longitude);\n    setCachedLocation(userLatLng);\n    map.setCenter(userLatLng);\n  });\n};"
          }
        },
        {
          "title": "지도 이동 시 마커 초기화 문제",
          "problem": "지도를 이동할 때 기존 마커가 유지되지 않고 다시 그려지는 문제 발생.",
          "solution": [
            "useFacilityMarkers 훅에서 기존 마커를 재사용할 수 있도록 개선.",
            "setCenter 호출 시 기존 마커가 유지되도록 수정.",
            "useEffect 의존성을 최소화하여 불필요한 리렌더링 방지."
          ],
          "lesson": "불필요한 상태 변경을 방지하고, 최소한의 리렌더링으로 데이터를 유지하는 것이 성능 최적화에 큰 영향을 미친다는 것을 배웠습니다. useEffect의 의존성을 관리하는 것이 중요한 이유를 다시 한번 실감했습니다."
        },
        {
          "title": "지역 검색 시 정확하지 않은 검색 결과",
          "problem": "검색된 지역명이 너무 길거나 복잡하여 API가 정확한 좌표를 반환하지 않는 경우 발생.",
          "solution": [
            "simplifyRegionName 유틸 함수를 사용하여 시/군/구 단위로 변환.",
            "kakao.maps.services.Geocoder() 호출 시 검색 결과를 검증하여 첫 번째 결과만 사용."
          ],
          "lesson": "외부 API를 사용할 때는 데이터가 항상 정확하다고 가정하면 안 된다는 점을 깨달았습니다. 데이터를 정제하고 가공하는 로직이 사용자 경험에 중요한 영향을 미친다는 점을 배웠습니다."
        }
      ]
    }
  },
  {
    "id": "global-nomad",
    "name": "Global Nomad",
    "description": "여행 시 체험 상품을 간편하게 예약하는 서비스",
    "image": "/images/projects/global-nomad.png",
    "techStack": [
      "React",
      "Next.js",
      "TypeScript",
      "React Query",
      "Zustand",
      "Tailwind CSS",
      "React Query",
      "ESlint",
      "Prettier"
    ],
    "deployLink": "https://nomad-ebon.vercel.app/",
    "githubLink": "https://github.com/eqypo9/global-nomad",
    "features": [
      "여행 체험 상품 예약 시스템",
      "지도 기반 위치 검색",
      "사용자 리뷰 시스템"
    ],
    "retrospective": "## 프로젝트 회고\n- **예약 시스템을 설계하며 백엔드 API와의 협업 중요성을 경험**\n- **React Query의 비동기 데이터 관리 최적화 기술 습득**",
    "troubleshooting": "## 트러블슈팅\n### 🚧 체험 상품 데이터가 업데이트되지 않음\n**🔍 문제:** React Query의 데이터가 자동으로 최신화되지 않음\n\n**✅ 해결:** React Query의 `refetchInterval`을 추가하여 최신 데이터 유지"
  },
  {
    "id": "the-julge",
    "name": "The Julge",
    "description": "알바 구직자와 사장님을 연결하는 서비스",
    "image": "/images/projects/the-julge.png",
    "techStack": [
      "React",
      "Next.js",
      "TypeScript",
      "Axios",
      "React Query",
      "Zustand",
      "Styled Components",
      "ESlint",
      "Prettier"
    ],
    "features": [
      "알바 구직자와 사장님 간 매칭 기능",
      "채팅 시스템을 활용한 실시간 커뮤니케이션",
      "구인 공고 및 지원 관리 기능"
    ],
    "deployLink": "https://the-julge.vercel.app/",
    "githubLink": "https://github.com/eqypo9/TheJulge"
  }
]
